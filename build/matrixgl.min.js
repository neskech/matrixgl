(()=>{var Y=class{get values(){return this._values}get magnitude(){let t=0;for(let e of this._values)t+=e**2;return Math.sqrt(t)}toString(){return`Vector${this._values.length}(${this._values.join(", ")})`}},X=class extends Y{get x(){return this._values[0]}get y(){return this._values[1]}set x(t){this._values[0]=t}set y(t){this._values[1]=t}},Z=class extends Y{get x(){return this._values[0]}get y(){return this._values[1]}get z(){return this._values[2]}set x(t){this._values[0]=t}set y(t){this._values[1]=t}set z(t){this._values[2]=t}},C=class extends Y{get x(){return this._values[0]}get y(){return this._values[1]}get z(){return this._values[2]}get w(){return this._values[3]}set x(t){this._values[0]=t}set y(t){this._values[1]=t}set z(t){this._values[2]=t}set w(t){this._values[3]=t}};var c=class extends X{constructor(t,e){super();this._values=new Float32Array([t,e])}add(t){return new c(this.x+t.x,this.y+t.y)}sub(t){return new c(this.x-t.x,this.y-t.y)}mult(t){return new c(this.x*t,this.y*t)}div(t){return new c(this.x/t,this.y/t)}floor(){return new c(Math.floor(this.x),Math.floor(this.y))}ceil(){return new c(Math.ceil(this.x),Math.ceil(this.y))}normalize(){let t=this.magnitude;return t===0?this:new c(this.x/t,this.y/t)}equals(t,e=1e-5){return Math.abs(this.x-t.x)<=e&&Math.abs(this.y-t.y)<=e}angle(){return Math.atan2(this.y,this.x)}rotateBy(t){return c.fromAngle(this.angle()+t).mult(this.magnitude)}rotateAbout(t,e){return this.sub(t).rotateBy(e).add(t)}dotProductWith(t){return this.x*t.x+this.y*t.y}crossProductWith(t){return new a(0,0,this.x*t.y-t.x*this.y)}clone(){return new c(this.x,this.y)}static lerp(t,e,r){let n=c.displacement(t,e),s=n.magnitude;return n.normalize().mult(r*s)}static lerpByDistance(t,e,r){return c.direction(t,e).mult(r)}static dotProduct(t,e){return t.dotProductWith(e)}static crossProduct(t,e){return new a(0,0,t.x*e.y-e.x*t.y)}static angleBetween(t,e){return Math.acos(c.dotProduct(t,e)/(t.magnitude*e.magnitude))}static distance(t,e){return c.displacement(t,e).magnitude}static distanceSquared(t,e){let r=c.distance(t,e);return r*r}static midpoint(t,e){return c.displacement(t,e).mult(.5).add(t)}static displacement(t,e){return e.sub(t)}static direction(t,e){return c.displacement(t,e).normalize()}static fromAngle(t){return new c(Math.cos(t),Math.sin(t))}},a=class extends Z{constructor(t,e,r){super();this._values=new Float32Array([t,e,r])}add(t){return new a(this.x+t.x,this.y+t.y,this.z+t.z)}sub(t){return new a(this.x-t.x,this.y-t.y,this.z-t.z)}mult(t){return new a(this.x*t,this.y*t,this.z*t)}div(t){return new a(this.x/t,this.y/t,this.z/t)}floor(){return new a(Math.floor(this.x),Math.floor(this.y),Math.floor(this.z))}ceil(){return new a(Math.ceil(this.x),Math.ceil(this.y),Math.ceil(this.z))}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}cross(t){let e=this.y*t.z-this.z*t.y,r=this.z*t.x-this.x*t.z,n=this.x*t.y-this.y*t.x;return new a(e,r,n)}normalize(){let t=this.magnitude;return t===0?this:new a(this.x/t,this.y/t,this.z/t)}static lerp(t,e,r){let n=a.displacement(t,e),s=n.magnitude;return n.normalize().mult(r*s)}static lerpByDistance(t,e,r){return a.direction(t,e).mult(r)}equals(t,e=1e-5){return Math.abs(this.x-t.x)<=e&&Math.abs(this.y-t.y)<=e&&Math.abs(this.z-t.z)<=e}dotProductWith(t){return this.x*t.x+this.y*t.y}clone(){return new a(this.x,this.y,this.z)}static dotProduct(t,e){return t.dotProductWith(e)}static crossProduct(t,e){return t.cross(e)}static angleBetween(t,e){return Math.acos(a.dotProduct(t,e)/(t.magnitude*e.magnitude))}static distance(t,e){return a.displacement(t,e).magnitude}static distanceSquared(t,e){let r=a.distance(t,e);return r*r}static midpoint(t,e){return a.displacement(t,e).mult(.5).add(t)}static displacement(t,e){return e.sub(t)}static direction(t,e){return a.displacement(t,e).normalize()}get xy(){return new c(this.x,this.y)}},m=class extends C{constructor(t,e,r,n){super();this._values=new Float32Array([t,e,r,n])}add(t){return new m(this.x+t.x,this.y+t.y,this.z+t.z,this.w+t.w)}sub(t){return new m(this.x-t.x,this.y-t.y,this.z-t.z,this.w-t.w)}mult(t){return new m(this.x*t,this.y*t,this.z*t,this.w*t)}div(t){return new m(this.x/t,this.y/t,this.z/t,this.w/t)}floor(){return new m(Math.floor(this.x),Math.floor(this.y),Math.floor(this.z),Math.floor(this.w))}ceil(){return new m(Math.ceil(this.x),Math.ceil(this.y),Math.ceil(this.z),Math.ceil(this.w))}normalize(){let t=this.magnitude;return t===0?this:new m(this.x/t,this.y/t,this.z/t,this.w/t)}static lerp(t,e,r){let n=m.displacement(t,e),s=n.magnitude;return n.normalize().mult(r*s)}static lerpByDistance(t,e,r){return m.direction(t,e).mult(r)}equals(t,e=1e-5){return Math.abs(this.x-t.x)<=e&&Math.abs(this.y-t.y)<=e&&Math.abs(this.z-t.z)<=e}dotProductWith(t){return this.x*t.x+this.y*t.y}clone(){return new m(this.x,this.y,this.z,this.w)}static dotProduct(t,e){return t.dotProductWith(e)}static angleBetween(t,e){return Math.acos(m.dotProduct(t,e)/(t.magnitude*e.magnitude))}static distance(t,e){return m.displacement(t,e).magnitude}static distanceSquared(t,e){let r=m.distance(t,e);return r*r}static midpoint(t,e){return m.displacement(t,e).mult(.5).add(t)}static displacement(t,e){return e.sub(t)}static direction(t,e){return m.displacement(t,e).normalize()}get xyz(){return new a(this.x,this.y,this.z)}};var w=class{constructor(t,e,r,n){this._values=new Float32Array([t,e,r,n])}static rotationAround(t,e){let r=Math.sin(e/2),n=Math.cos(e/2);return new w(t.x*r,t.y*r,t.z*r,n)}normalize(){let t=this.magnitude;if(t===0)return this;let e=1/t;return new w(this.x*e,this.y*e,this.z*e,this.w*e)}add(t){return new w(this.x+t.x,this.y+t.y,this.z+t.z,this.w+t.w)}mulByScalar(t){return new w(this.x*t,this.y*t,this.z*t,this.w*t)}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}slerp(t,e,r={chooseShorterAngle:!0}){let n=this.dot(t),s=t;n<0&&(n=-n,s=t.mulByScalar(-1));let u=Math.acos(n),i=Math.sin(u),l=this.mulByScalar(Math.sin((1-e)*u)/i),h=s.mulByScalar(Math.sin(e*u)/i);return l.add(h)}get magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}get norm(){return this.magnitude}get x(){return this._values[0]}get y(){return this._values[1]}get z(){return this._values[2]}get w(){return this._values[3]}set x(t){this._values[0]=t}set y(t){this._values[1]=t}set z(t){this._values[2]=t}set w(t){this._values[3]=t}get values(){return this._values}toRotationMatrix4(){let t=this.x,e=this.y,r=this.z,n=this.w,s=1-2*e*e-2*r*r,u=2*t*e-2*n*r,i=2*t*r+2*n*e,l=0,h=2*t*e+2*n*r,b=1-2*t*t-2*r*r,x=2*e*r-2*n*t,d=0,y=2*t*r-2*n*e,p=2*e*r+2*n*t,v=1-2*t*t-2*e*e,V=0,M=0,g=0,z=0,f=1;return new o(s,h,y,M,u,b,p,g,i,x,v,z,l,d,V,f)}toString(){return`Quaternion(${this.x}, ${this.y}, ${this.z}, ${this.w})`}};var U=class{constructor(t,e,r,n){this._values=new Float32Array([t,e,r,n])}static identity(){return new U(1,0,0,1)}get values(){return this._values}toString(){return this._values.toString()}},D=class{constructor(t,e,r,n,s,u,i,l,h){this._values=new Float32Array([t,e,r,n,s,u,i,l,h])}static identity(){return new D(1,0,0,0,1,0,0,0,1)}get values(){return this._values}toString(){return this._values.toString()}},o=class{constructor(t,e,r,n,s,u,i,l,h,b,x,d,y,p,v,V){this._values=new Float32Array([t,e,r,n,s,u,i,l,h,b,x,d,y,p,v,V])}static identity(){return new o(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}static translation(t,e,r){return new o(1,0,0,0,0,1,0,0,0,0,1,0,t,e,r,1)}static scaling(t,e,r){return new o(t,0,0,0,0,e,0,0,0,0,r,0,0,0,0,1)}static rotationX(t){let e=Math.sin(t),r=Math.cos(t);return new o(1,0,0,0,0,r,e,0,0,-e,r,0,0,0,0,1)}static rotationY(t){let e=Math.sin(t),r=Math.cos(t);return new o(r,0,-e,0,0,1,0,0,e,0,r,0,0,0,0,1)}static rotationZ(t){let e=Math.sin(t),r=Math.cos(t);return new o(r,e,0,0,-e,r,0,0,0,0,1,0,0,0,0,1)}static rotationAround(t,e){return w.rotationAround(t,e).toRotationMatrix4()}static lookAt(t,e,r){let n=t.sub(e).normalize(),s=r.cross(n).normalize(),u=n.cross(s).normalize();return new o(s.x,u.x,n.x,0,s.y,u.y,n.y,0,s.z,u.z,n.z,0,-t.dot(s),-t.dot(u),-t.dot(n),1)}static orthographic(t){let e=t.top,r=t.bottom,n=t.left,s=t.right,u=t.near,i=t.far;return new o(2/(s-n),0,0,0,0,2/(e-r),0,0,0,0,-2/(i-u),0,-(s+n)/(s-n),-(e+r)/(e-r),-(i+u)/(i-u),1)}static frustum(t){let e=t.top,r=t.bottom,n=t.left,s=t.right,u=t.near,i=t.far;return new o(2*u/(s-n),0,0,0,0,2*u/(e-r),0,0,(s+n)/(s-n),(e+r)/(e-r),-(i+u)/(i-u),-1,0,0,-2*i*u/(i-u),0)}static perspective(t){let e=t.near*Math.tan(t.fovYRadian*.5),r=e*2,n=t.aspectRatio*r,s=-.5*n,u=s+n,i=e-r;return o.frustum({top:e,bottom:i,left:s,right:u,near:t.near,far:t.far})}mulByMatrix4x4(t){let e=this._values[0],r=this._values[4],n=this._values[8],s=this._values[12],u=this._values[1],i=this._values[5],l=this._values[9],h=this._values[13],b=this._values[2],x=this._values[6],d=this._values[10],y=this._values[14],p=this._values[3],v=this._values[7],V=this._values[11],M=this._values[15],g=t.values[0],z=t.values[4],f=t.values[8],A=t.values[12],B=t.values[1],F=t.values[5],S=t.values[9],T=t.values[13],q=t.values[2],P=t.values[6],Q=t.values[10],k=t.values[14],W=t.values[3],L=t.values[7],R=t.values[11],$=t.values[15],E=e*g+r*B+n*q+s*W,G=e*z+r*F+n*P+s*L,H=e*f+r*S+n*Q+s*R,J=e*A+r*T+n*k+s*$,K=u*g+i*B+l*q+h*W,N=u*z+i*F+l*P+h*L,_=u*f+i*S+l*Q+h*R,j=u*A+i*T+l*k+h*$,O=b*g+x*B+d*q+y*W,tt=b*z+x*F+d*P+y*L,et=b*f+x*S+d*Q+y*R,rt=b*A+x*T+d*k+y*$,nt=p*g+v*B+V*q+M*W,st=p*z+v*F+V*P+M*L,ut=p*f+v*S+V*Q+M*R,it=p*A+v*T+V*k+M*$;return new o(E,K,O,nt,G,N,tt,st,H,_,et,ut,J,j,rt,it)}mulByMatrix4(t){return this.mulByMatrix4x4(t)}translate(t,e,r){let n=o.translation(t,e,r);return this.mulByMatrix4x4(n)}scale(t,e,r){let n=o.scaling(t,e,r);return this.mulByMatrix4x4(n)}rotateX(t){let e=o.rotationX(t);return this.mulByMatrix4x4(e)}rotateY(t){let e=o.rotationY(t);return this.mulByMatrix4x4(e)}rotateZ(t){let e=o.rotationZ(t);return this.mulByMatrix4x4(e)}rotateAround(t,e){let r=o.rotationAround(t,e);return this.mulByMatrix4x4(r)}get values(){return this._values}toString(){return this._values.toString()}},bt=U,xt=D,dt=o;})();
